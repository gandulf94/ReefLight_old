/*
 * Copyright (c) 2018 Michael Dahsler
 * Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation 
 * files (the "Software"), to deal in the Software without restriction, including without limitation the rights to use, copy, 
 * modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software 
 * is furnished to do so, subject to the following conditions:
 * 
 * The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.
 * 
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES 
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE 
 * LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR 
 * IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. 
 */

#include "channel.h"
#include "debug.h"
#include "ntp.h"
#include <Arduino.h>
#include <Wire.h>
#include <Adafruit_PWMServoDriver.h>

/*
 * Global variables
 */
uint8_t numOfChannels; // current number of used channels
uint32_t PWMFrequency; // frequency used to generate the PWM Signal
uint16_t PWMGenerator; // defines if the PWM signal is generated by the ESP8266 itself or the PCA9685
unsigned long millisAtLastPWMUpdate; // millis upime of the device since the last PWM Update
Channel channels[MAX_NUM_OF_CHANNELS]; // array storing all channels
Adafruit_PWMServoDriver PCA9685Shield = Adafruit_PWMServoDriver(); // Object representing the PCA9685 PWM Module


/*
 * Constructor, Destructor
 */
Channel::Channel() {}
Channel::~Channel() {}


/*
 * Prints all information of the channel
 */
void Channel::print() {
  DEBUG_INFO("Channel: %d", channelNumber);
  DEBUG_INFO("Name: %s", name);
  DEBUG_INFO("Color: %s", color);
  DEBUG_INFO("Pin: %d", pin);
  DEBUG_INFO("Power: %f", power);
  DEBUG_INFO("Manual: %d", manual);
  DEBUG_INFO("Moonlight: %d", moonlight);
  DEBUG_INFO("Max Moonlight value: %f", maxMoonlightValue);
  DEBUG_INFO("value: %f", value);
  DEBUG_INFO("Number of entries: %d", numOfEntries);
  DEBUG_INFO("Entry | Time | Value [%]");
  for(uint8_t i=0; i<numOfEntries; i++)  DEBUG_INFO("%d | %d | %d\n",i,t[i],v[i]);
}


/*
 * Updates the PWM signal every "MILLIS_BETWEEN_PWM_UPDATES"
 * therefore the "value" is updated according to the lightschedule if the
 * channel is in automatic mode ("manual" == false)
 * Ff the channel is in manual mode ("manual" == true) "value" is not updated according to 
 * the lightschedule
 * If the channel is in moonlight mode ("moonlight" == true), "value" is calculated according to 
 * the moonlight simulation
 * 
 * In the end the Â¨value" is defining the new duty cycle of the PWM signal generated by "PWMGenerator"
 */
void Channel::updatePWM() {
  
  if(moonlight) {
    // moonlight simulation TODO
    value = 0;
    DEBUG_INFO("[Channel::updatePWM {%d}] moonlight, value: %f", channelNumber, value);

  }
  else {
    String m;
    // calculate PWM value in automatic mode
    if(!manual) {
      m = "automatic";
      uint32_t t_ = getLocalSecondsOfTheDay();
      for(uint8_t i=0; i<numOfEntries; i++) {
        uint32_t t1 = t[i];
        uint32_t t2 = t[(i+1)%numOfEntries];
        uint8_t v1 = v[i];
        uint8_t v2 = v[(i+1)%numOfEntries];
        if(i+1 == numOfEntries) {
          t2 += 24*60*60;
          if(t_<t1) t_ += 24*60*60;
        }
        if(t1<t_ && t_<= t2) {
          value = v1 + (v2-v1)/float(t2-t1)*float(t_-t1);
        }
      }
    }
    // no update in automatic mode
    if(manual) {
      m = "manual";
    }
    DEBUG_INFO("[Channel::updatePWM {%d}] mode: %s, value: %f", channelNumber, m.c_str(), value);
  }
  // set pwm
  switch(PWMGenerator) {
    case PWM_GENERATOR_ESP8266:
      analogWrite(pin, value/100. * 1023);
      break;
    case PWM_GENERATOR_PCA9685:
      PCA9685Shield.setPWM(channelNumber, 0, float(value/100. * 4095));
      break;
  }    
}


/*
 * prints all channels also the not active ones
 */
void printAllChannels() {
  for(uint8_t c=0; c<MAX_NUM_OF_CHANNELS; c++) channels[c].print();
}


/*
 * Configures the PWMGenerator
 * if the PWM is generated by the ESP8266 the pins are set as outputs
 * if the PWM is generated by the PCA9685 the I2C module is configured
 */
void configurePWM() {
  millisAtLastPWMUpdate = 0;
  
  switch(PWMGenerator) {
    case PWM_GENERATOR_ESP8266:
      DEBUG_INFO("[configurePWM] pwm generated by ESP8266");
      for(uint8_t c=0; c<numOfChannels; c++) {
        pinMode(channels[c].pin, OUTPUT);
        digitalWrite(channels[c].pin, 0);
      }
      break;
    case PWM_GENERATOR_PCA9685:
      DEBUG_INFO("[configurePWM] pwm generated by PCA9685");
      PCA9685Shield.begin();
      for(uint8_t c=0; c<numOfChannels; c++) PCA9685Shield.setPin(c, 0, false);     
      break;
  }
  setPWMFrequency(PWMFrequency);
}


/*
 * sets a new PWM frequency in Hz
 */
void setPWMFrequency(const uint32_t f) {
  DEBUG_INFO("[setPWMFrequency] new frequency: %d Hz",f);
  PWMFrequency = f;
  switch(PWMGenerator) {
    case PWM_GENERATOR_ESP8266:
      analogWriteFreq(f);
      break;
    case PWM_GENERATOR_PCA9685:
      PCA9685Shield.setPWMFreq(f);
      break;
  }  
}


/*
 * handles the PWM generation in the main loop
 * every "MILLIS_BETWEEN_PWM_UPDATES" the PWM values are updated
 * if (force == true) the update is forced
 */
void handlePWM(const bool force) {
  if(millis() - millisAtLastPWMUpdate > MILLIS_BETWEEN_PWM_UPDATES || force) {
    for(uint8_t c=0; c<numOfChannels; c++) channels[c].updatePWM();
    millisAtLastPWMUpdate = millis();
  }
}



